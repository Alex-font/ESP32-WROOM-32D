#include <Adafruit_SSD1306.h>
#include <Wire.h>
#include <WiFi.h>           // Бібліотека для роботи з Wi-Fi
#include <HTTPClient.h>     // Бібліотека для відправки HTTP запитів
#include <ArduinoJson.h>    // Бібліотека для роботи з JSON
#include <time.h>           // Бібліотека для роботи з часом
#include "config.h"         // Включає файл config.h, який містить дані про Wi-Fi та API_KEY

// Налаштування для OLED дисплея
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

const String apiUrl = "http://api.openweathermap.org/data/2.5/weather?q=Kyiv,UA&units=metric&appid=" + String(API_KEY);

// Змінні для зберігання отриманих даних про погоду
float currentTemperature = 0.0;
float feelsLikeTemperature = 0.0;
float minTemperature = 0.0;
float maxTemperature = 0.0;
float windSpeed = 0.0;
String windDirection = "Невідомо";
float pressure = 0.0;
const char* currentWeatherDescription = "Невідомо";
float precipitation = 0.0;
float humidity = 0.0; // Змінна для вологості

unsigned long lastWeatherUpdate = 0; // Для зберігання часу останнього оновлення погоди
const unsigned long weatherUpdateInterval = 300000; // Інтервал оновлення погоди (5 хвилин)

void setup() {
    Serial.begin(115200); 
    WiFi.begin(ssid, password); 

    while (WiFi.status() != WL_CONNECTED) { 
        delay(500);
        Serial.print(".");
    }
    Serial.println(" WiFi connected.");

    configTime(2 * 3600, 0, "pool.ntp.org", "time.nist.gov"); 

    struct tm timeinfo;
    if (!getLocalTime(&timeinfo)) {
        Serial.println("Не вдалося отримати час через інтернет");
        return;
    }
    Serial.println("Час синхронізовано з NTP-сервером");

    // Ініціалізація OLED дисплея
    if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { 
        Serial.println(F("Не вдалося знайти OLED дисплей"));
        for(;;);
    }
    display.clearDisplay();
    display.display();

    fetchWeather();
}

void displayDataOnOLED() {
    display.clearDisplay();

    display.setTextSize(1); 
    display.setTextColor(SSD1306_WHITE);

    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
        const char* daysOfWeek[] = {"Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Нд"};
        int dayIndex = (timeinfo.tm_wday + 6) % 7; 
        display.setCursor(0, 0);
        display.printf("%s %02d:%02d:%02d", daysOfWeek[dayIndex], timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);

        display.setCursor(0, 10);
        display.printf("Температура: %.1f C", currentTemperature);
        display.setCursor(0, 20);
        display.printf("Відчувається: %.1f C", feelsLikeTemperature);
        display.setCursor(0, 30);
        display.printf("H: %.1f C L: %.1f C", maxTemperature, minTemperature);
        display.setCursor(0, 40);
        display.printf("Вологість: %.1f%%", humidity);
        display.setCursor(0, 50);
        display.printf("Тиск: %.1f гПа", pressure);

        display.display();
    } else {
        Serial.println("Використовуємо внутрішній таймер через відсутність з'єднання.");
    }
}

void displayTime() {
    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) { 
        const char* daysOfWeek[] = {"Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Нд"};
        int dayIndex = (timeinfo.tm_wday + 6) % 7;
        Serial.print(daysOfWeek[dayIndex]);
        Serial.print(" ");
        Serial.printf("%02d:%02d:%02d %02d/%02d/%04d\n", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900);
        
        Serial.print("Температура: ");
        Serial.print(currentTemperature);
        Serial.println(" °C");

        Serial.print("Відчувається як: ");
        Serial.print(feelsLikeTemperature);
        Serial.println(" °C");

        Serial.print("H-Температура: ");
        Serial.print(maxTemperature);
        Serial.println(" °C");

        Serial.print("L-Температура: ");
        Serial.print(minTemperature);
        Serial.println(" °C");

        Serial.print("Вологість: ");
        Serial.print(humidity);
        Serial.println(" %");

        Serial.print("Опади: ");
        Serial.print(precipitation);
        Serial.println(" мм");

        Serial.print("Опис погоди: ");
        Serial.println(currentWeatherDescription);

        Serial.print("Напрям вітру: ");
        Serial.print(windDirection);
        Serial.print(" зі швидкістю ");
        Serial.print(windSpeed);
        Serial.println(" м/с");

        Serial.print("Тиск: ");
        Serial.print(pressure);
        Serial.println(" гПа");
    }
}

void fetchWeather() {
    if (WiFi.status() == WL_CONNECTED) {
        HTTPClient http;
        http.begin(apiUrl);

        int httpCode = http.GET();
        if (httpCode > 0) {
            String payload = http.getString();
            Serial.println("Weather data: " + payload);

            DynamicJsonDocument doc(2048);
            deserializeJson(doc, payload);

            currentTemperature = doc["main"]["temp"];
            feelsLikeTemperature = doc["main"]["feels_like"];
            minTemperature = doc["main"]["temp_min"];
            maxTemperature = doc["main"]["temp_max"];
            pressure = doc["main"]["pressure"];
            windSpeed = doc["wind"]["speed"];
            humidity = doc["main"]["humidity"];

            float windDeg = doc["wind"]["deg"];
            if (windDeg >= 0 && windDeg < 45) windDirection = "Північний";
            else if (windDeg >= 45 && windDeg < 90) windDirection = "Східний";
            else if (windDeg >= 90 && windDeg < 135) windDirection = "Південно-східний";
            else if (windDeg >= 135 && windDeg < 180) windDirection = "Південний";
            else if (windDeg >= 180 && windDeg < 225) windDirection = "Південно-західний";
            else if (windDeg >= 225 && windDeg < 270) windDirection = "Західний";
            else if (windDeg >= 270 && windDeg < 315) windDirection = "Північно-західний";
            else windDirection = "Північний";

            if (doc.containsKey("rain")) {
                precipitation = doc["rain"]["1h"];
            } else {
                precipitation = 0;
            }

            const char* weatherId = doc["weather"][0]["description"];
            if (strcmp(weatherId, "few clouds") == 0) {
                currentWeatherDescription = "мало хмарно";
            } else if (strcmp(weatherId, "clear sky") == 0) {
                currentWeatherDescription = "ясно";
            } else if (strcmp(weatherId, "overcast clouds") == 0) {
                currentWeatherDescription = "похмуро";
            } else if (strcmp(weatherId, "light rain") == 0) {
                currentWeatherDescription = "дощ";
            } else if (strcmp(weatherId, "moderate rain") == 0) {
                currentWeatherDescription = "помірний дощ";
            } else if (strcmp(weatherId, "heavy rain") == 0) {
                currentWeatherDescription = "сильний дощ";
            } else if (strcmp(weatherId, "scattered clouds") == 0) {
                currentWeatherDescription = "розсіяні хмари";
            } else if (strcmp(weatherId, "broken clouds") == 0) {
                currentWeatherDescription = "розірвані хмари";
            } else {
                currentWeatherDescription = "інше";
            }
        } else {
            Serial.println("Не вдалося отримати дані про погоду.");
        }

        http.end();
    }
}

void loop() {
    displayTime();

    unsigned long currentMillis = millis();
    if (currentMillis - lastWeatherUpdate >= weatherUpdateInterval) {
        fetchWeather();
        lastWeatherUpdate = currentMillis;
    }

    displayDataOnOLED();
    delay(1000);
}
